# TP4 : Real services

Dans ce TP4, on va s'approcher de plus en plus vers de la gestion de serveur, commen on le fait dans le monde r√©el.

Le but de ce TP :

‚ûú **monter un serveur de stockage** VM `storage.tp4.linux`

- le serveur de stockage poss√®de une partition d√©di√©e
- sur cette partition, plusieurs dossiers sont cr√©√©s
- chaque dossier contient un site web
- ces dossiers sont partag√©s √† travers le r√©seau pour rendre leur contenu disponible √† notre serveur web

‚ûú **monter un serveur web** VM `web.tp4.linux`

- il accueillera deux sites web
- il ne sera (malheureusement) pas publi√© sur internet : c'est juste une VM
- les sites web sont stock√©s sur le serveur de stockage, le serveur web y acc√®de √† travers le r√©seau

---

‚ûú Plut√¥t que de monter des petits services de test, ou analyser les services d√©j√† existants sur la machine, on va donc passer √† l'√©tape sup√©rieure et **monter des trucs vraiment utilis√©s dans le monde r√©el** 

Rien de sorcier cela dit, et **√† la fin vous aurez appris √† monter un petit serveur Web.** Ce serait exactement la m√™me chose si vous voulez publier un site web, et que vous voulez g√©rer vous-m√™mes le serveur Web.

**Le serveur de stockage** c'est pour rendre le truc un peu plus fun (oui j'ai os√© dire *fun*), et voir un service de plus, qui est utilis√© dans le monde r√©el. En plus, il est parfaitement adapt√© pour pratiquer et s'exercer sur le partitionnement de fa√ßon pertinente.

‚ûú On aura besoin de deux VMs dans ce TP : üñ•Ô∏è **VM `web.tp4.linux`** et üñ•Ô∏è **VM `storage.tp4.linux`**.

> Pour une meilleure lisibilit√©, j'ai √©clat√© le TP en 3 parties.

# Partie 1 : Partitionnement du serveur de stockage

> Cette partie est √† r√©aliser sur üñ•Ô∏è **VM storage.tp4.linux**.

On va ajouter un disque dur √† la VM, puis le partitionner, afin de cr√©er un espace d√©di√© qui accueillera nos sites web.

‚ûú **Ajouter deux disques durs de 2G √† la VM**

- cela se fait via l'interface graphique de virtualbox
- il faut √©teindre la VM pour ce faire

> [**R√©f√©rez-vous au m√©mo LVM pour r√©aliser le reste de cette partie.**](../../../cours/memo/lvm.md)

**Le partitionnement est obligatoire pour que le disque soit utilisable.** Ici on va rester simple : une seule partition, qui prend toute la place offerte par le disque.

Comme vu en cours, le partitionnement dans les syst√®mes GNU/Linux s'effectue g√©n√©ralement √† l'aide de *LVM*.

**Allons !**


üåû **Partitionner le disque √† l'aide de LVM**

- cr√©er 2 *physical volumes (PV)* :
  - un PV ajout√© pour chacun des disques
  - chaque PV fait donc 2G

  ```golang
  [vince@vm2 ~]$ sudo pvdisplay
  Devices file sys_wwid t10.ATA_VBOX_HARDDISK_VB5ad3db88-792a8c5c PVID NAAaUiQQdJVUNoa80HboRnaJlqi9Sh22 last seen on /dev/sda2 not found.
  "/dev/sdb" is a new physical volume of "2.00 GiB"
  --- NEW Physical volume ---
  PV Name               /dev/sdb
  VG Name
  PV Size               2.00 GiB
  Allocatable           NO
  PE Size               0
  Total PE              0
  Free PE               0
  Allocated PE          0
  PV UUID               im3asG-6Qg9-O1Nf-eIot-2rTk-NMr1-RXtGM9

  "/dev/sdc" is a new physical volume of "2.00 GiB"
  --- NEW Physical volume ---
  PV Name               /dev/sdc
  VG Name
  PV Size               2.00 GiB
  Allocatable           NO
  PE Size
  ```
- cr√©er un nouveau *volume group (VG)*
  - il devra s'appeler `storage`
  - il doit contenir les deux PVs cr√©√©s √† l'√©tape pr√©c√©dente

  ```golang
  [vince@vm2 ~]$ sudo vgdisplay
  Devices file sys_wwid t10.ATA_VBOX_HARDDISK_VB5ad3db88-792a8c5c PVID NAAaUiQQdJVUNoa80HboRnaJlqi9Sh22 last seen on /dev/sda2 not found.
  --- Volume group ---
  VG Name               storage
  System ID
  Format                lvm2
  Metadata Areas        2
  Metadata Sequence No  2
  VG Access             read/write
  VG Status             resizable
  MAX LV                0
  Cur LV                0
  Open LV               0
  Max PV                0
  Cur PV                2
  Act PV                2
  VG Size               3.99 GiB
  PE Size               4.00 MiB
  Total PE              1022
  Alloc PE / Size       0 / 0
  Free  PE / Size       1022 / 3.99 GiB
  VG UUID               FvMj9x-CQfT-NRo0-u8OG-SSJz-CLTx-mJl45s
  ```

- cr√©er un nouveau *logical volume (LV)* : ce sera la partition utilisable
  - elle doit √™tre dans le VG `storage`
  - elle doit occuper tout l'espace libre

```golang
[vince@vm2 ~]$ sudo lvdisplay
  Devices file sys_wwid t10.ATA_VBOX_HARDDISK_VB5ad3db88-792a8c5c PVID NAAaUiQQdJVUNoa80HboRnaJlqi9Sh22 last seen on /dev/sda2 not found.
  --- Logical volume ---
  LV Path                /dev/storage/storage
  LV Name                storage
  VG Name                storage
  LV UUID                hH7KsP-BmUB-whcs-80HS-cG3D-dowO-CsUTm9
  LV Write Access        read/write
  LV Creation host, time vm2.tp4.b1, 2024-02-20 09:28:00 +0100
  LV Status              available
  # open                 0
  LV Size                3.99 GiB
  Current LE             1022
  Segments               2
  Allocation             inherit
  Read ahead sectors     auto
  - currently set to     256
  Block device           253:2
  ```


üåû **Formater la partition**

- vous formaterez la partition en ext4 (avec une commande `mkfs`)
  - le chemin de la partition, vous pouvez le visualiser avec la commande `lvdisplay`
```golang
  [vince@vm2 ~]$ mkfs -t ext4 /dev/storage/storage
mke2fs 1.46.5 (30-Dec-2021)
mkfs.ext4: Permission denied while trying to determine filesystem size
[vince@vm2 ~]$ sudo !!
sudo mkfs -t ext4 /dev/storage/storage
mke2fs 1.46.5 (30-Dec-2021)
Creating filesystem with 1046528 4k blocks and 261632 inodes
Filesystem UUID: 85610353-103f-4031-8320-078a49aff167
Superblock backups stored on blocks:
        32768, 98304, 163840, 229376, 294912, 819200, 884736

Allocating group tables: done
Writing inode tables: done
Creating journal (16384 blocks): done
Writing superblocks and filesystem accounting information: done
``` 

  - pour rappel un *Logical Volume (LVM)* **C'EST** une partition

üåû **Monter la partition**

- montage de la partition (avec la commande `mount`)
  - la partition doit √™tre mont√©e dans le dossier `/storage`

  - preuve avec une commande `df -h` que la partition est bien mont√©e
```golang
  [vince@vm2 ~]$ df -h
Filesystem                   Size  Used Avail Use% Mounted on
devtmpfs                     4.0M     0  4.0M   0% /dev
tmpfs                        386M     0  386M   0% /dev/shm
tmpfs                        155M  3.7M  151M   3% /run
/dev/mapper/rl-root          6.2G  1.2G  5.0G  20% /
/dev/sda1                   1014M  220M  795M  22% /boot
tmpfs                         78M     0   78M   0% /run/user/1000
/dev/mapper/storage-storage  3.9G   24K  3.7G   1% /mnt/storage
```

  - utilisez un `| grep` pour isoler les lignes int√©ressantes

```golang
[vince@vm2 ~]$ df -h | grep storage
/dev/mapper/storage-storage  3.9G   24K  3.7G   1% /mnt/storage
```
  - prouvez que vous pouvez lire et √©crire des donn√©es sur cette partition

  ```golang
[vince@vm2 ~]$ cat /mnt/storage/fichier_vince
coucou
```
- d√©finir un montage automatique de la partition (fichier `/etc/fstab`)
  - vous v√©rifierez que votre fichier `/etc/fstab` fonctionne correctement

```golang
  [vince@vm2 ~]$ sudo umount /mnt/storage
[vince@vm2 ~]$ sudo mount -av
/                        : ignored
/boot                    : already mounted
none                     : ignored
mount: /mnt/storage does not contain SELinux labels.
       You just mounted a file system that supports labels which does not
       contain labels, onto an SELinux box. It is likely that confined
       applications will generate AVC messages and not be allowed access to
       this file system.  For more details see restorecon(8) and mount(8).
mount: (hint) your fstab has been modified, but systemd still uses
       the old version; use 'systemctl daemon-reload' to reload.
/mnt/storage             : successfully mounted
```

Ok ! Za, z'est fait. On a un espace de stockage d√©di√© pour stocker nos sites web.

‚≠ê**BONUS**

- utilisez une commande `dd` pour remplir compl√®tement la nouvelle partition
- prouvez que la partition est remplie avec une commande `df`
- ajoutez un nouveau disque dur de 2G √† la machine
- ajoutez ce new disque dur √† la conf LVM
- agrandissez la partition pleine √† l'aide du nouveau disque
- prouvez aavec un `df` que la partition a bien √©t√© agrandie

**Passons √† [la partie 2 : installation du serveur de partage de fichiers](./../part2/README.md).**


# Partie 2 : Serveur de partage de fichiers

**Dans cette partie, le but sera de monter un serveur de stockage.** Un serveur de stockage, ici, d√©signe simplement un serveur qui partagera un dossier ou plusieurs aux autres machines de son r√©seau.

Ce dossier sera h√©berg√© sur la partition d√©di√©e sur la machine **`storage.tp4.linux`**.

Afin de partager le dossier, **nous allons mettre en place un serveur NFS** (pour Network File System), qui est pr√©vu √† cet effet. Comme d'habitude : c'est un programme qui √©coute sur un port, et les clients qui s'y connectent avec un programme client adapt√© peuvent acc√©der √† un ou plusieurs dossiers partag√©s.

Le **serveur NFS** sera **`storage.tp4.linux`** et le **client NFS** sera **`web.tp4.linux`**.

L'objectif :

- avoir deux dossiers sur **`storage.tp4.linux`** partag√©s
  - `/storage/site_web_1/`
  - `/storage/site_web_2/`
- la machine **`web.tp4.linux`** monte ces deux dossiers √† travers le r√©seau
  - le dossier `/storage/site_web_1/` est mont√© dans `/var/www/site_web_1/`
  - le dossier `/storage/site_web_2/` est mont√© dans `/var/www/site_web_2/`

üåû **Donnez les commandes r√©alis√©es sur le serveur NFS `storage.tp4.linux`**

```golang
[vince@vm2 ~]$ sudo dnf install nfs-utils
[vince@vm2 ~]$ sudo mkdir /storage/site_web_1 -p
[vince@vm2 ~]$ sudo mkdir /storage/site_web2 -p
[vince@vm2 ~]$ ls -dl /storage/site_web_1
drwxr-xr-x. 2 root root 6 Feb 20 10:44 /storage/site_web_1
[vince@vm2 ~]$ sudo chown nobody /storage/site_web_1
[vince@vm2 ~]$ ls -dl /storage/site_web_1
drwxr-xr-x. 2 nobody root 6 Feb 20 10:44 /storage/site_web_1
[vince@vm2 ~]$ ls -dl /storage/site_web_2
drwxr-xr-x. 2 root root 6 Feb 20 10:49 /storage/site_web_2
[vince@vm2 ~]$ sudo chown nobody /storage/site_web_2
[vince@vm2 ~]$ sudo dnf install nano
Last metadata expiration check: 1:19:16 ago on Tue 20 Feb 2024 09:31:50 AM CET.
Package nano-5.6.1-5.el9.x86_64 is already installed.
Dependencies resolved.
Nothing to do.
Complete!
[vince@vm2 ~]$ sudo nano /etc/exports
[vince@vm2 ~]$ sudo systemctl enable nfs-server
[sudo] password for vince:
[vince@vm2 ~]$ sudo systemctl status nfs-server
- contenu du fichier `/etc/exports` dans le compte-rendu notamment
[vince@vm2 ~]$ sudo firewall-cmd --permanent --list-all | grep services
  services: cockpit dhcpv6-client mountd nfs rpc-bind ssh
```
```golang
  [vince@vm2 ~]$ cat /etc/exports
/storage/site_web_1 10.4.1.3(rw,sync,no_subtree_check)
/storage/site_web_2 10.4.1.3(rw,sync,no_subtree_check)
```


üåû **Donnez les commandes r√©alis√©es sur le client NFS `web.tp4.linux`**

```golang
[vince@web ~]$ sudo dnf install nfs-utils
[sudo] password for vince:
[vince@web ~]$ sudo mkdir -p /var/www/site_web_1
[sudo] password for vince:
[vince@web ~]$ sudo mkdir -p /var/www/site_web_2
[vince@web ~]$ sudo mount 10.4.1.4:/storage/site_web_1 /var/www/site_we
b_1
[vince@web ~]$ sudo mount 10.4.1.4:/storage/site_web_2 /var/www/site_we
b_2
[vince@web ~]$ df -h
Filesystem                    Size  Used Avail Use% Mounted on
devtmpfs                      4.0M     0  4.0M   0% /dev
tmpfs                         386M     0  386M   0% /dev/shm
tmpfs                         155M  3.7M  151M   3% /run
/dev/mapper/rl-root           6.2G  1.2G  5.0G  20% /
/dev/sda1                    1014M  220M  795M  22% /boot
tmpfs                          78M     0   78M   0% /run/user/1000
10.4.1.4:/storage/site_web_1  6.2G  1.2G  5.0G  20% /var/www/site_web_1
10.4.1.4:/storage/site_web_2  6.2G  1.2G  5.0G  20% /var/www/site_web_2
[vince@web ~]$ sudo touch /var/www/site_web_1/fichier_test
[vince@web ~]$ ls -l /var/www/site_web_1/fichier_test
-rw-r--r--. 1 nobody nobody 0 Feb 20  2024 /var/www/site_web_1/fichier_test
```


- contenu du fichier `/etc/fstab` dans le compte-rendu notamment
```golang
[vince@web ~]$ cat /etc/fstab

#
# /etc/fstab
# Created by anaconda on Mon Oct 23 09:14:19 2023
#
# Accessible filesystems, by reference, are maintained under '/dev/disk/'.
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info.
#
# After editing this file, run 'systemctl daemon-reload' to update systemd
# units generated from this file.
#
/dev/mapper/rl-root     /                       xfs     defaults        0 0
UUID=98eba154-d188-4a39-a469-80eecdcf345d /boot                   xfs     defaults        0 0
/dev/mapper/rl-swap     none                    swap    defaults        0 0

10.4.1.4 : /storage/site_web_1 /var/www/site_web_1 nfs auto,nofail,noatime,nolock,intr,tcp,actimeo=1800 0 0
```



> Je vous laisse vous inspirer de docs sur internet **[comme celle-ci](https://www.digitalocean.com/community/tutorials/how-to-set-up-an-nfs-mount-on-rocky-linux-9)** pour mettre en place un serveur NFS.

**Ok, on a fini avec la partie 2, let's head to [the part 3](./../part3/README.md).**




# Partie 3 : Serveur web

- [Partie 3 : Serveur web](#partie-3--serveur-web)
  - [1. Intro NGINX](#1-intro-nginx)
  - [2. Install](#2-install)
  - [3. Analyse](#3-analyse)
  - [4. Visite du service web](#4-visite-du-service-web)
  - [5. Modif de la conf du serveur web](#5-modif-de-la-conf-du-serveur-web)
  - [6. Deux sites web sur un seul serveur](#6-deux-sites-web-sur-un-seul-serveur)

## 1. Intro NGINX


**NGINX (prononc√© "engine-X") est un serveur web.** C'est un outil de r√©f√©rence aujourd'hui, il est r√©put√© pour ses performances et sa robustesse.

Un serveur web, c'est un programme qui √©coute sur un port et qui attend des requ√™tes HTTP. Quand il re√ßoit une requ√™te de la part d'un client, il renvoie une r√©ponse HTTP qui contient le plus souvent de l'HTML, du CSS et du JS.

> Une requ√™te HTTP c'est par exemple `GET /index.html` qui veut dire "donne moi le fichier `index.html` qui est stock√© sur le serveur". Le serveur renverra alors le contenu de ce fichier `index.html`.

Ici on va pas DU TOUT s'attarder sur la partie d√©v web √©tou, une simple page HTML fera l'affaire.

Une fois le serveur web NGINX install√© (gr√¢ce √† un paquet), sont cr√©√©s sur la machine :

- **un service** (un fichier `.service`)
  - on pourra interagir avec le service √† l'aide de `systemctl`
- **des fichiers de conf**
  - comme d'hab c'est dans `/etc/` la conf
  - comme d'hab c'est bien rang√©, donc la conf de NGINX c'est dans `/etc/nginx/`
  - question de simplicit√© en terme de nommage, le fichier de conf principal c'est `/etc/nginx/nginx.conf`
- **une racine web**
  - c'est un dossier dans lequel un site est stock√©
  - c'est √† dire l√† o√π se trouvent tous les fichiers PHP, HTML, CSS, JS, etc du site
  - ce dossier et tout son contenu doivent appartenir √† l'utilisateur qui lance le service
- **des logs**
  - tant que le service a pas trop tourn√© c'est empty
  - les fichiers de logs sont dans `/var/log/`
  - comme d'hab c'est bien rang√© donc c'est dans `/var/log/nginx/`
  - on peut aussi consulter certains logs avec `sudo journalctl -xe -u nginx`

> Chaque log est √† sa place, on ne trouve pas la m√™me chose dans chaque fichier ou la commande `journalctl`. La commande `journalctl` vous permettra de rep√©rer les erreurs que vous glisser dans les fichiers de conf et qui emp√™che le d√©marrage correct de NGINX.

## 2. Install

üñ•Ô∏è **VM web.tp4.linux**

üåû **Installez NGINX**

- installez juste NGINX (avec un `dnf install`) et passez √† la suite
- r√©f√©rez-vous √† des docs en ligne si besoin

```golang
[vince@web ~]$ sudo dnf install nginx
```

## 3. Analyse

Avant de config des truks 2 ouf √©tou, on va lancer √† l'aveugle et inspecter ce qu'il se passe, inspecter avec les outils qu'on conna√Æt ce que fait NGINX √† notre OS.

Commencez donc par d√©marrer le service NGINX :

```bash
$ sudo systemctl start nginx
$ sudo systemctl status nginx
```

üåû **Analysez le service NGINX**

- avec une commande `ps`, d√©terminer sous quel utilisateur tourne le processus du service NGINX
  - utilisez un `| grep` pour isoler les lignes int√©ressantes
```golang
[vince@web ~]$ ps aux | grep nginx
root       12488  0.0  0.1  10108   956 ?        Ss   10:22   0:00 nginx: master process /usr/sbin/nginx
nginx      12489  0.0  0.6  13908  4960 ?        S    10:22   0:00 nginx: worker process
vince      12535  0.0  0.2   6408  2276 pts/0    S+   10:29   0:00 grep --color=auto nginx
```
- avec une commande `ss`, d√©terminer derri√®re quel port √©coute actuellement le serveur web
  - utilisez un `| grep` pour isoler les lignes int√©ressantes
- en regardant la conf, d√©terminer dans quel dossier se trouve la racine web
  - utilisez un `| grep` pour isoler les lignes int√©ressantes
- inspectez les fichiers de la racine web, et v√©rifier qu'ils sont bien accessibles en lecture par l'utilisateur qui lance le processus
  - √ßa va se faire avec un `ls` et les options appropri√©es

## 4. Visite du service web

**Et √ßa serait bien d'acc√©der au service non ?** Genre c'est un serveur web. On veut voir un site web !

üåû **Configurez le firewall pour autoriser le trafic vers le service NGINX**

- vous avez reper√© avec `ss` dans la partie d'avant le port √† ouvrir

üåû **Acc√©der au site web**

- avec votre navigateur sur VOTRE PC
  - ouvrez le navigateur vers l'URL : `http://<IP_VM>:<PORT>`
- vous pouvez aussi effectuer des requ√™tes HTTP depuis le terminal, plut√¥t qu'avec un navigateur
  - √ßa se fait avec la commande `curl`
  - et c'est √ßa que je veux dans le compte-rendu, pas de screen du navigateur :)

> Si le port c'est 80, alors c'est la convention pour HTTP. Ainsi, il est inutile de le pr√©ciser dans l'URL, le navigateur le fait de lui-m√™me. On peut juste saisir `http://<IP_VM>`.

üåû **V√©rifier les logs d'acc√®s**

- trouvez le fichier qui contient les logs d'acc√®s, dans le dossier `/var/log`
- les logs d'acc√®s, c'est votre serveur web qui enregistre chaque requ√™te qu'il a re√ßu
- c'est juste un fichier texte
- affichez les 3 derni√®res lignes des logs d'acc√®s dans le contenu rendu, avec une commande `tail`

## 5. Modif de la conf du serveur web

üåû **Changer le port d'√©coute**

- une simple ligne √† modifier, vous me la montrerez dans le compte rendu
  - faites √©couter NGINX sur le port 8080
- red√©marrer le service pour que le changement prenne effet
  - `sudo systemctl restart nginx`
  - v√©rifiez qu'il tourne toujours avec un ptit `systemctl status nginx`
- prouvez-moi que le changement a pris effet avec une commande `ss`
  - utilisez un `| grep` pour isoler les lignes int√©ressantes
- n'oubliez pas de fermer l'ancien port dans le firewall, et d'ouvrir le nouveau
- prouvez avec une commande `curl` sur votre machine que vous pouvez d√©sormais visiter le port 8080

> L√† c'est pas le port par convention, alors oblig√© de pr√©ciser le port quand on fait la requ√™te avec le navigateur ou `curl` : `http://<IP_VM>:8080`.

---

üåû **Changer l'utilisateur qui lance le service**

- pour √ßa, vous cr√©erez vous-m√™me un nouvel utilisateur sur le syst√®me : `web`
  - r√©f√©rez-vous au [m√©mo des commandes](../../cours/memos/commandes.md) pour la cr√©ation d'utilisateur
  - l'utilisateur devra avoir un mot de passe, et un homedir d√©fini explicitement √† `/home/web`
- modifiez la conf de NGINX pour qu'il soit lanc√© avec votre nouvel utilisateur
  - utilisez `grep` pour me montrer dans le fichier de conf la ligne que vous avez modifi√©
- n'oubliez pas de red√©marrer le service pour que le changement prenne effet
- vous prouverez avec une commande `ps` que le service tourne bien sous ce nouveau utilisateur
  - utilisez un `| grep` pour isoler les lignes int√©ressantes

---

**Il est temps d'utiliser ce qu'on a fait √† la partie 2 !**

üåû **Changer l'emplacement de la racine Web**

- configurez NGINX pour qu'il utilise une autre racine web que celle par d√©faut
  - avec un `nano` ou `vim`, cr√©ez un fichiez `/var/www/site_web_1/index.html` avec un contenu texte bidon
  - dans la conf de NGINX, configurez la racine Web sur `/var/www/site_web_1/`
  - vous me montrerez la conf effectu√©e dans le compte-rendu, avec un `grep`
- n'oubliez pas de red√©marrer le service pour que le changement prenne effet
- prouvez avec un `curl` depuis votre h√¥te que vous acc√©dez bien au nouveau site

> **Normalement le dossier `/var/www/site_web_1/` est un dossier cr√©√© √† la Partie 2 du TP**, et qui se trouve en r√©alit√© sur le serveur `storage.tp4.linux`, notre serveur NFS.

![MAIS](../img/nop.png)

## 6. Deux sites web sur un seul serveur

Dans la conf NGINX, vous avez du rep√©rer un bloc `server { }` (si c'est pas le cas, allez le rep√©rer, la ligne qui d√©finit la racine web est contenu dans le bloc `server { }`).

Un bloc `server { }` permet d'indiquer √† NGINX de servir un site web donn√©.

Si on veut h√©berger plusieurs sites web, il faut donc d√©clarer plusieurs blocs `server { }`.

**Pour √©viter que ce soit le GROS BORDEL dans le fichier de conf**, et se retrouver avec un fichier de 150000 lignes, on met chaque bloc `server` dans un fichier de conf d√©di√©.

Et le fichier de conf principal contient une ligne qui inclut tous les fichiers de confs additionnels.

üåû **Rep√©rez dans le fichier de conf**

- la ligne qui inclut des fichiers additionels contenus dans un dossier nomm√© `conf.d`
- vous la mettrez en √©vidence avec un `grep`

> On trouve souvent ce m√©canisme dans la conf sous Linux : un dossier qui porte un nom finissant par `.d` qui contient des fichiers de conf additionnels pour pas foutre le bordel dans le fichier de conf principal. On appelle ce dossier un dossier de *drop-in*.

üåû **Cr√©ez le fichier de configuration pour le premier site**

- le bloc `server` du fichier de conf principal, vous le sortez
- et vous le mettez dans un fichier d√©di√©
- ce fichier d√©di√© doit se trouver dans le dossier `conf.d`
- ce fichier d√©di√© doit porter un nom ad√©quat : `site_web_1.conf`

üåû **Cr√©ez le fichier de configuration pour le deuxi√®me site**

- un nouveau fichier dans le dossier `conf.d`
- il doit porter un nom ad√©quat : `site_web_2.conf`
- copiez-collez le bloc `server { }` de l'autre fichier de conf
- changez la racine web vers `/var/www/site_web_2/`
- et changez le port d'√©coute pour 8888

> N'oubliez pas d'ouvrir le port 8888 dans le firewall. Vous pouvez constater si vous le souhaitez avec un `ss` que NGINX √©coute bien sur ce nouveau port.

üåû **Prouvez que les deux sites sont disponibles**

- depuis votre PC, deux commandes `curl`
- pour choisir quel site visitez, vous choisissez un port sp√©cifique